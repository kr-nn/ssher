#!/usr/bin/env bash
#
# What is this?
# This is a general tool for SSH and auditability. No need to learn complex software like ansible
# This is a simpler quicker to RnD ansible
# This is a simpler tool that uses only 1 dependancy and it's optional: sshpass
# Otherwise all you need is a posix compliant shell and ssh
#
# What is it not?
# This is NOT a state management or configuration management engine.
# This does NOT replace SALT/puppet/Chef
# This will not expand past a few simple but robust capabilities

###############################################################
### Initial Variables #########################################
###############################################################

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CLEAR='\033[0m'

###############################################################
### Help Dialog ###############################################
###############################################################

show_help() {
  echo -e "
$(printf '=%.0s' $(seq 1 $(tput cols)))
 ${GREEN}███████╗███████╗██╗  ██╗███████╗██████╗ 
 ${GREEN}██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗
 ${GREEN}███████╗███████╗███████║█████╗  ██████╔╝
 ${GREEN}╚════██║╚════██║██╔══██║██╔══╝  ██╔══██╗
 ${GREEN}███████║███████║██║  ██║███████╗██║  ██║
 ${GREEN}╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝${CLEAR}
$(printf '=%.0s' $(seq 1 $(tput cols)))
  Usage:${RED} $0 ${GREEN}mode -i inventory_file_path [-u username] [ -o 'ssh options' ] [-p] [-s private_key] [-l local_file] [-r remote_file] [-c 'command'] [-J jobs] [-a a|o]

  Options:
 ${RED}      mode                ${GREEN}Specifies the mode of operation. Options are 'run', 'script', 'ping', 'upload', 'collect', 'update'
 ${RED}                          ${GREEN}use 'debug' to get output of the options per server
 ${RED}                          ${GREEN}This option is required.
 ${RED}
 ${RED}                          ${GREEN}run       =  Run a command on all the servers
 ${RED}                          ${GREEN}script    =  Like run except runs a full script you have locally. If you need to run a script on the server or from a remote location use the run mode.
 ${RED}                          ${GREEN}ping      =  Test SSH access to servers, reports the auth mechanism
 ${RED}                          ${GREEN}upload    =  Add contents of a local file to a target file on the server. Good for pushing public keys with password mode (better than ssh-copy-id)
 ${RED}                          ${GREEN}collect   =  Pull contents from remote servers to the local server. Great for auditing/updating configurations.
 ${RED}                          ${GREEN}update    =  Take a collect file from collect mode and upload to each server.
 ${RED}                          ${GREEN}debug     =  output what is going to run on each server. Useful when using special variables to change things dynamically
 ${RED}
 ${RED}   -i inventory_file      ${GREEN}Path to the file containing a list of server hostnames or IP addresses.
 ${RED}                          ${GREEN}This option is required.
 ${RED}
 ${RED}   -I inventory_file      ${GREEN}Rich inventory file (JSON). Enables host-level overrides.
 ${RED}                          ${GREEN}Fields fall back to CLI defaults when omitted.
 ${RED}
 ${RED}   -o options             ${GREEN}define custom ssh options
 ${RED}                          ${GREEN}just like in normal ssh you can pass -o options.
 ${RED}                          ${GREEN}by default stricthostchecking is disabled, connection timeouts are set to 8 seconds, and batchmode is activated
 ${RED}                          ${GREEN}this is not limited to -o you can pass ANY ssh options to this flag
 ${RED}                          ${GREEN}If you use this option stricthostchecking and the connectiontimout options are removed, you will need to add them again
 ${RED}
 ${RED}   -J jobs                ${GREEN}parallel jobs. default is cpu count
 ${RED}
 ${RED}   -a append/overwrite    ${GREEN}determines automatically without prompt whether you want to append or overwrite files in certain modes
 ${RED}
 ${RED}   -p                     ${GREEN}Prompts for a password for password authentication. (THIS REQUIRES SSHPASS)
 ${RED}                          ${GREEN}If not provided, you will have to enter the password for each server that needs it.
 ${RED}                          ${GREEN}Not using this is useful when you have different passwords on different servers
 ${RED}
 ${RED}   -l local_file          ${GREEN}Specifies the file which content to push. Optional.
 ${RED}                          ${GREEN}Default is your public key 'id_rsa.pub'.
 ${RED}                          ${GREEN}Used in script mode to define the script you want to run
 ${RED}
 ${RED}   -r remote_file         ${GREEN}Specifies the file to push local file contents to. Optional.
 ${RED}                          ${GREEN}Default is the remote authorized keys file 'authorized_keys'.
 ${RED}
 ${RED}   -s Private_key         ${GREEN}Specifies the identity key file to use for authentication. Optional.
 ${RED}                          ${GREEN}Default is according to your config file or just 'id_rsa'.
 ${RED}
 ${RED}   -u username            ${GREEN}Specifies the username for the operation. Optional.
 ${RED}                          ${GREEN}Default is the current user's username.
 ${RED}
 ${RED}   -c command             ${GREEN}The command to run when in run mode.
 ${RED}                          ${GREEN}Wrap with \"\" when there's spaces (most of the time)
 ${RED}
  Examples:
   ${RED}ssher ${GREEN}run -i oldservers.txt -c 'apt update && apt upgrade -y && apt autoremove -y'                    ${CLEAR}# Update a list of servers
   ${RED}ssher ${GREEN}ping -i serversthatshouldbelocked.txt -u root -p | tee sshaudit.txt                             ${CLEAR}# Check what servers are not secured
   ${RED}ssher ${GREEN}upload -i newserver.txt -u newkid -l ~/.ssh/newuser.pub                                            ${CLEAR}# Add a new users public key to the server
   ${RED}ssher ${GREEN}ping -i servers.txt -u root -o '-J root@jumphost.ip' -u root                                    ${CLEAR}# Add a jumphost for pivoting from
   ${RED}ssher ${GREEN}upload -i service.txt -u root -l ./config.txt -d /etc/service/configuration.txt                    ${CLEAR}# set configuration file on server
   ${RED}ssher ${GREEN}ping -i servers.txt -u user -s ~/.ssh/newkey.id_rsa                                             ${CLEAR}# Check what servers have your new key
   ${RED}ssher ${GREEN}script -i servers.txt -u root -l ~/.local/bin/profileconfig.sh                                  ${CLEAR}# configure your shell profile on all servers
   ${RED}ssher ${GREEN}collect -i servers.txt -u root -l ~/reports/\$date_auth.log -r /var/log/auth.log                ${CLEAR}# pull all the auth logs to investigate today's access
   ${RED}ssher ${GREEN}update -i servers.txt -u root -l ~/.confs/static_ips -r /etc/networking/interfaces              ${CLEAR}# after collecting interfaces files you and update them, then upload them
   ${RED}ssher ${GREEN}run -i servers.txt -u root -c 'reboot'                                                          ${CLEAR}# reboot all servers
   ${RED}ssher ${GREEN}run -i servers.txt -u root -c 'systemctl --failed'                                              ${CLEAR}# list all failed services in your network

  PROTIPS:
  ${RED}building inventories is easy with nmap:${GREEN} nmap -n -Pn -p 22 192.168.4.0/24 -oG - | grep 'open' | awk '{ print $2 }'

  ${RED}Create a Report that you can read:${CLEAR}
  ${GREEN}ssher ping -i ips.list |tee date.report${CLEAR} # This outputs the color mask for bash, make sure to cat the file to get the color output appropriately
                             ${GREEN}cat date.report${CLEAR} # vim does not render ANSI escape codes without help use cat, more, less as much as you can

$(printf '=%.0s' $(seq 1 $(tput cols)))" | less

}

###############################################################
### Argument parser ###########################################
###############################################################
# Capture original output for debugging
origcommand="$0 $@"

# Detect option collisions
declare -A SET SRC
set_opt() {
  local key=$1 val=$2 src=$3
  if [[ -v SET[$key] ]]; then
    echo "error: '$key' specified twice (first ${SRC[$key]}, then $src)"
    exit 1
  fi
  SET[$key]=$val
  SRC[$key]=$src
  printf -v "$key" '%s' "$val"
}


# Parse
OPTS=$(getopt -o m:i:I:o:u:s:a:pl:r:c:d -l debug:,dryrun:,inventory:,inventory-rich:,options:,user:,username:,append:,idfile:,password,localfile:,remotefile:,cmd:,command: -- "$@") || exit 2
eval set -- "$OPTS"
while true; do
  case "$1" in
    -i|--inventory)          set_opt inventory       "$2" "$1";  shift 2;;
    -I|--inventory-rich)     set_opt inventory_rich  "$2" "$1";  shift 2;;
    -o|--options)            set_opt options         "$2" "$1";  shift 2;;
    -u|--user|--username)    set_opt username        "$2" "$1";  shift 2;;
    -s|--idfile)             set_opt idfile          "$2" "$1";  shift 2;;
    -l|--localfile)          set_opt localfile       "$2" "$1";  shift 2;;
    -r|--remotefile)         set_opt remotefile      "$2" "$1";  shift 2;;
    -a|--append)             set_opt append          "$2" "$1";  shift 2;;
    -c|--cmd|--command)      set_opt cmd             "$2" "$1";  shift 2;;
    -p|--password)           set_opt password        "1"  "$1";  shift 1;;
    -d|--dryrun|--debug)     set_opt debug           "1"  "$1";  shift 1;;
    --) shift; break;;
    -*) show_help; exit 1;;
  esac
done

[ ! -z $debug ] && echo "Original Command: $origcommand";

rich_mode=0
if [ ! -z "$inventory_rich" ]; then
  [ ! -z "$inventory" ] && { echo "FATAL: choose one inventory source (-i or -I)"; exit 1; }
  inventory="$inventory_rich"
  rich_mode=1
fi

# Set mode
mode="${1:-}"; shift

case "$mode" in
    test|ping|run|script|upload|collect|update|debug) ;;
    ""|*) show_help; exit 1; ;;
esac

###############################################################
### Preflight #################################################
###############################################################

#######################
### Capabilities ######
#######################
[ -z $(command -v sshpass) ] || { sshpass=1; }
[ -x $(command -v jq) ] || { jq=1; }

#######################
### Defaults ##########
#######################
[ -z "$username" ] && username=$USER
[ ! -z "$idfile" ] && idfilecmd=" -i ${idfile}"
[ "$rich_mode" -eq 0 ] && batch=" -o BatchMode=yes " || batch=" "
[ -z "$options" ] && { optionscmd="${batch}-o StrictHostKeyChecking=no -o ConnectTimeout=3"; }
[ ! -z "$options" ] && { optionscmd=" ${options} ${batch} "; }

#######################
### Early failures ####
#######################
[ -z "$mode" ] || [ -z "$inventory" ] && { show_help && exit 1; }
[ ! -f "$inventory" ] && { echo "FATAL: Selected inventory file (${inventory}) doesn't seem to exist. Check your pwd."; exit 1; }
[ "$rich_mode" -eq 1 ] && { command -v jq >/dev/null 2>&1 || { echo "FATAL: jq is required when using -I"; exit 1; }; }
[ ! -z "$password" ] && [ -z "$sshpass" ] && { echo "FATAL: sshpass is not available and -p was used"; exit 1; }
if [ ! -z "$idfile" ]; then # We still continue because you can defer to external configuration for auth id
  [ ! -f "$idfile" ] && { echo "FATAL: Selected private key ${idfile} doesn't seem to exist."; exit 1; }
  ssh-keygen -yf $idfile &>/dev/null || { echo "FATAL: Selected private key ${idfile} is malformed, ensure this is a real key"; exit 1; }
fi
if [ ! -z "$append" ]; then
  case $append in
      "o"|"O"|"overwrite"|"a"|"A"|"append") ;;
      ""|*) echo "FATAL: --append offered with no valid argument"; exit 1;
  esac
fi
case $mode in "test"|"script"|"upload"|"collect"|"update")
    [ -z "$localfile" ] && { echo "FATAL: Local file required when in $mode mode"; exit 1; } ;;
esac
case $mode in "test"|"upload"|"collect"|"update")
    [ -z "$remotefile" ] && { echo "FATAL: Remote file required when in $mode mode"; exit 1; } ;;
esac
case $mode in "test"|"script"|"upload"|"update")
    [ -f "$localfile" ] || { echo "FATAL: Local file $localfile doesn't seem to exist"; exit 1; } ;;
esac
case $mode in "test"|"run")
    [ -z "$cmd" ] && { echo "FATAL: Command is required in run mode"; exit 1; } ;;
esac

#######################
### Inputs Required ###
#######################
[ -z "$password" ] || { read -s -p "Please enter the password for traditional authentication: " password; echo ""; }
[ "$mode" == "update" ] || [ "$mode" == "test" ] && [ -z "$append" ] && read -n 1 -r -p "Using update mode, Append or Override? O/A? " append
case "$append" in
    "o"|"O"|"overwrite") overwrite=1 ;;
  *) ;;
esac

#######################
### command builder ###
#######################
[ ! -z "$password" ] && { passwordcmd="sshpass -p ${password} "; passwordcmdredacted="sshpass -p REDACTED "; }

sshcmdredacted="${passwordcmdredacted}ssh $username@-------${idfilecmd}${optionscmd}"
sshcmd="${passwordcmd}ssh ${idfilecmd}${optionscmd}"

#######################
### Confirmation ######
#######################

echo ""
[ ! -z "$idfilecmd" ] && echo -e "Private Key: ${GREEN}$idfile${CLEAR}"

if [ "$mode" == "upload" ] || [ "$mode" == "test" ]; then
  if [ "$overwrite" == "1" ]; then
      echo -e "Write mode: ${RED}Overwrite${CLEAR}"
  else
      echo -e "Write mode: ${GREEN}Append${CLEAR}"
  fi
fi

case $mode in "test"|"script"|"upload"|"collect"|"update")
    echo -e "local file: ${GREEN}$localfile${CLEAR}" ;;
esac
case $mode in "test"|"upload"|"collect"|"update")
    echo -e "remote file: ${GREEN}$remotefile${CLEAR}" ;;
esac

echo -e "Username: ${GREEN}$username${CLEAR}"
echo -e "Servers to attempt (cat the file if you're unsure): ${GREEN}$inventory${CLEAR}"

case $mode in "test"|"run")
    echo -e "Command: ${GREEN}$cmd${CLEAR}" ;;
esac

echo -e "SSH: ${GREEN}${sshcmdredacted}${CLEAR}"

if [ ! "$mode" == "test" ]; then
  countdowntime=3
  while [ $countdowntime -gt 0 ]; do
      echo -ne "${RED}Make sure to read this! $countdowntime\033[0K\r${CLEAR}"
      sleep 1
      countdowntime=$((countdowntime-1))
  done

  read -n 1 -r -p "Are you sure you want to run this? [y/n] " confirm
  case "$confirm" in
      [yY][eE][sS]|[yY])
          ;;
      *)
          exit 1
          ;;
  esac
  echo ""
  echo "=============================================================="
else
  case $mode in
    "run") echo "run was triggered" ;;
    "script") echo "script was triggered" ;;
    "ping") echo "ping was triggered" ;;
    "upload") echo "upload was triggered" ;;
    "collect") echo "collect was triggered" ;;
    "update") echo "update was triggered" ;;
    "test") echo "We are testing" ;;
  esac
  exit 0
fi

###############################################################
### helper functions ##########################################
###############################################################

draw_tui() {
    queued=$((total_hosts - success_hosts - failed_hosts))
    printf '\rQueued: %d / Success: %d / Failed: %d    ' "$queued" "$success_hosts" "$failed_hosts"
}

cleanup_jobs() {
    [[ $usetui -eq 1 ]] && { tput cnorm; usetui=0; }
    [[ "$job_tmpdir" != 0 && -d "$job_tmpdir" ]] && rm -rf "$job_tmpdir"
    job_tmpdir=0
}

launch_job() {
    idx="$1"
    server="${servers[$idx]}"
    outfile="$job_tmpdir/$idx"
    local extra_string="${server_extras[$idx]}"
    local -a extra_args=()
    if [ -n "$extra_string" ]; then
        IFS=' ' read -r -a extra_args <<< "$extra_string"
    fi
    local host_password="${server_passwords[$idx]}"
    local host_localfile="${server_localfiles[$idx]}"
    local host_idfile="${server_idfiles[$idx]}"
    local host_username="${server_usernames[$idx]}"
    local host_cmd="${server_cmds[$idx]}"
    local host_remotefile="${server_remotefiles[$idx]}"
    local host_overwrite="${server_overwrites[$idx]}"
    local host_sshcmd="${server_sshcmds[$idx]}"
    (
        "${current_runner}" \
            "$server" \
            "$outfile" \
            "$inventory" \
            "$host_password" \
            "$host_localfile" \
            "$host_idfile" \
            "$host_username" \
            "$host_cmd" \
            "$host_remotefile" \
            "$host_overwrite" \
            "$host_sshcmd" \
            "${extra_args[@]}"
    ) &
    pids[$idx]=$!
}

process_servers() {
    current_runner="$1"
    jobs="${jobs:-$(command -v nproc >/dev/null 2>&1 && nproc || echo 1)}"
    if ! [[ "$jobs" =~ ^[0-9]+$ ]] || [ "$jobs" -lt 1 ]; then
        jobs=1
    fi
    usetui=0
    servers=()
    server_extras=()
    server_usernames=()
    server_passwords=()
    server_idfiles=()
    server_localfiles=()
    server_remotefiles=()
    server_cmds=()
    server_overwrites=()
    server_sshcmds=()
    if [ "$rich_mode" -eq 1 ]; then
        local -a servers_raw=()
        if ! mapfile -t servers_raw < <(jq -r '
            def val(x): if x == null then "" else x end;
            (if type=="array" then .[] else . end)
            | [val(.host), val(.user), val(.id), val(.password), val(.append), val(.options), val(.localfile), val(.remotefile), val(.command)]
            | join("\u001f")
        ' "$inventory"); then
            echo "FATAL: failed to parse rich inventory (${inventory})"
            exit 1
        fi
        for entry in "${servers_raw[@]}"; do
            [[ -z "$entry" ]] && continue
            IFS=$'\x1f' read -r host host_user host_id host_password_raw host_append host_options host_local host_remote host_cmd_raw <<< "$entry"
            [[ -z "$host" ]] && { echo "FATAL: rich inventory entry missing host"; exit 1; }
            local resolved_user="$host_user"
            [ -z "$resolved_user" ] && resolved_user="$username"
            local resolved_idfile="$host_id"
            [ -z "$resolved_idfile" ] && resolved_idfile="$idfile"
            local resolved_local="$host_local"
            [ -z "$resolved_local" ] && resolved_local="$localfile"
            local resolved_remote="$host_remote"
            [ -z "$resolved_remote" ] && resolved_remote="$remotefile"
            local resolved_cmd="$host_cmd_raw"
            [ -z "$resolved_cmd" ] && resolved_cmd="$cmd"
            [ "$mode" == "run" ] || [ "$mode" == "test" ] || [ "$mode" == "debug" ] || resolved_cmd=""
            local resolved_password="$host_password_raw"
            local resolved_passwordcmd=""
            if [ -z "$resolved_password" ]; then
                resolved_password="$password"
                resolved_passwordcmd="$passwordcmd"
            else
                [ -z "$sshpass" ] && { echo "FATAL: sshpass is required for password auth (${host})"; exit 1; }
                resolved_passwordcmd="sshpass -p ${resolved_password} "
            fi
            local resolved_idcmd="$idfilecmd"
            if [ -n "$resolved_idfile" ]; then
                resolved_idcmd=" -i ${resolved_idfile}"
            fi
            local resolved_optionscmd="$optionscmd"
            if [ -n "$host_options" ]; then
                resolved_optionscmd=" ${host_options} -o BatchMode=yes"
            fi
            local resolved_overwrite="${overwrite:-0}"
            local append_value="$host_append"
            [ -z "$append_value" ] && append_value="$append"
            if [ -n "$append_value" ]; then
                case "$append_value" in
                    "o"|"O"|"overwrite") resolved_overwrite=1 ;;
                    *) resolved_overwrite=0 ;;
                esac
            fi
            local resolved_sshcmd="${resolved_passwordcmd}ssh${resolved_idcmd}${resolved_optionscmd}"
            servers+=("$host")
            server_extras+=("")
            server_usernames+=("$resolved_user")
            server_passwords+=("$resolved_password")
            server_idfiles+=("$resolved_idfile")
            server_localfiles+=("$resolved_local")
            server_remotefiles+=("$resolved_remote")
            server_cmds+=("$resolved_cmd")
            server_overwrites+=("$resolved_overwrite")
            server_sshcmds+=("$resolved_sshcmd")
        done
    else
        local -a servers_raw=()
        mapfile -t servers_raw < "$inventory"
        for entry in "${servers_raw[@]}"; do
            entry="${entry%%$'\r'}"
            entry="${entry#"${entry%%[![:space:]]*}"}"
            [[ -z "${entry}" ]] && continue
            [[ "${entry:0:1}" == "#" ]] && continue
            local host rest=""
            IFS=' ' read -r host rest <<< "$entry"
            servers+=("$host")
            server_extras+=("$rest")
            server_usernames+=("$username")
            server_passwords+=("$password")
            server_idfiles+=("$idfile")
            server_localfiles+=("$localfile")
            server_remotefiles+=("$remotefile")
            local inherited_cmd="$cmd"
            [ "$mode" == "run" ] || [ "$mode" == "test" ] || [ "$mode" == "debug" ] || inherited_cmd=""
            server_cmds+=("$inherited_cmd")
            server_overwrites+=("${overwrite:-0}")
            server_sshcmds+=("$sshcmd")
        done
    fi
    total_hosts=${#servers[@]}
    [[ $total_hosts -eq 0 ]] && { cleanup_jobs; trap - EXIT; return; }
    success_hosts=0
    failed_hosts=0
    pids=()
    job_tmpdir=$(mktemp -d)
    trap cleanup_jobs EXIT
    if [ -t 1 ] && [ "$jobs" -gt 1 ]; then
        usetui=1
        tput civis
        draw_tui
    fi
    launch_idx=0
    active=0
    declare -A pid_index=()
    while [ $launch_idx -lt $total_hosts ] || [ $active -gt 0 ]; do
        while [ $launch_idx -lt $total_hosts ] && [ $active -lt "$jobs" ]; do
            launch_job "$launch_idx"
            pid=${pids[$launch_idx]}
            pid_index[$pid]=$launch_idx
            launch_idx=$((launch_idx+1))
            active=$((active+1))
        done
        for pid in "${!pid_index[@]}"; do
            wait "$pid"
            status=$?
            idx=${pid_index[$pid]}
            unset pid_index["$pid"]
            active=$((active-1))
            if [ $status -eq 0 ]; then
                success_hosts=$((success_hosts+1))
            else
                failed_hosts=$((failed_hosts+1))
            fi
            if [ $usetui -eq 1 ]; then
                draw_tui
            fi
            break
        done
    done
    if [ $usetui -eq 1 ]; then
        printf '\rQueued: 0 / Success: %d / Failed: %d    \n' "$success_hosts" "$failed_hosts"
        tput cnorm
        usetui=0
    fi
    if [ "$mode" == "collect" ]; then
        for ((idx=0; idx<total_hosts; idx++)); do
            server="${servers[$idx]}"
            echo "" >> "$localfile"
            echo "##\$\$##| ${server} |##\$\$##" >> "$localfile"
            data_file="$job_tmpdir/${idx}.data"
            [ -f "$data_file" ] && cat "$data_file" >> "$localfile"
        done
    fi
    for ((idx=0; idx<total_hosts; idx++)); do
        cat "$job_tmpdir/$idx"
    done
    cleanup_jobs
    trap - EXIT
}

###############################################################
### Jobs ######################################################
###############################################################
run_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local ssh_output status
    ssh_output=$($_sshcmd "${_username}@${server}" "${_cmd}" 2>&1 )
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

script_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local ssh_output status
    ssh_output=$($_sshcmd "${_username}@${server}" 'bash -s' < "$_localfile" 2>&1 )
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

ping_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local ssh_output status
    ssh_output=$($_sshcmd "${_username}@${server}" -v exit 0 2>&1 )
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            if echo "$ssh_output" | grep -q "Server accepts key:"; then
                echo -e "${GREEN}Public key authentication${CLEAR}"
            else
                echo -e "${YELLOW}Password Authentication${CLEAR}"
            fi
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

upload_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local ov=">>"
    [ "$_overwrite" -eq 1 ] 2>/dev/null && ov=">"
    local ssh_output status
    ssh_output=$($_sshcmd "${_username}@${server}" "cat $ov ${_remotefile}" < "$_localfile" 2>&1 )
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $_localfile"
            echo "To: $_remotefile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

collect_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local data_file="${outfile}.data"
    local ssh_output status
    ssh_output=$($_sshcmd "${_username}@${server}" "cat ${_remotefile}" > "$data_file" 2>&1 )
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $_remotefile"
            echo "To: $_localfile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

update_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    local ov=">>"
    [ "$_overwrite" -eq 1 ] 2>/dev/null && ov=">"
    local content ssh_output status
    content=$(sed -n "/^##\$\$##| ${server} |##\$\$##$/,/^##\$\$##| /{ /^##\$\$##| ${server} |##\$\$##$/d; /^##\$\$##| /d; p; }" "$_localfile" | sed '/^$/d')
    ssh_output=$($_sshcmd "${_username}@${server}" "echo $content $ov $_remotefile" 2>&1 )
    status=$?
    local _sshcmd="${11}"
    shift 11
    local -a extra_args=("$@")
    {
        echo "# ============================ ${server} ==================================="
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $_localfile"
            echo "To: $_remotefile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

debug_job() {
    local server="$1"
    local outfile="$2"
    local _inventory="$3"
    local _password="$4"
    local _localfile="$5"
    local _idfile="$6"
    local _username="$7"
    local _cmd="$8"
    local _remotefile="$9"
    local _overwrite="${10:-0}"
    {
        echo "=============================================================="
        echo -e "${GREEN}debug mode - ${server}${CLEAR}"
        echo "--------------------------------------------------------------"
        echo -e "Inventory:   ${GREEN}  ${_inventory}  ${CLEAR}"
        echo -e "Username:    ${GREEN}  ${_username}  ${CLEAR}"
        echo -e "Idfile:      ${GREEN}  ${_idfile}  ${CLEAR}"
        echo -e "Password:    ${GREEN}  ${_password}  ${CLEAR}"
        echo -e "local file:  ${GREEN}  ${_localfile}  ${CLEAR}"
        echo -e "remote file: ${GREEN}  ${_remotefile}  ${CLEAR}"
        echo -e "Command:     ${GREEN}  ${_cmd}  ${CLEAR}"
    } > "$outfile"
}

###############################################################
### Modes #####################################################
###############################################################

run() {
    [[ "$cmd" == 0 ]] && { echo "FATAL: you need -c to run a command on the servers"; exit 0; }
    [[ "$cmd" == '' ]] && { echo "FATAL: empty commands make your shell broken"; exit 1; }
    process_servers run_job
}

#_ Script ==============================================================
script() {
    # fail if option is missing
    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to choose a script file locally"
        exit 0
    fi

    # Fail if local file is not found
    if [ ! -f "$localfile" ]; then
        echo "FATAL: Selected local file (${localfile}) doesn't seem to exist. Check your pwd."
        exit 1
    fi

    process_servers script_job
}

#_ ping ==============================================================
ping() {
    process_servers ping_job
}

#_ upload ==============================================================
upload() {
    # Fail if requirements are missing
    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to have content to push"
        exit 0
    fi

    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to push the content to"
        exit 0
    fi

    # Fail if local file is not found
    if [ ! -f "$localfile" ]; then
        echo "FATAL: Selected local file (${localfile}) doesn't seem to exist. Check your pwd."
        exit 1
    fi

    process_servers upload_job
}

#_ collect ==============================================================
collect() {

    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to put the content somewhere"
        exit 0
    fi

    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to pull the content"
        exit 0
    fi

    process_servers collect_job
}

#_ update ==============================================================
update() {

    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to push the content somewhere"
        exit 0
    fi
    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to put the content somewhere"
        exit 0
    fi

    process_servers update_job
}


#_ debug ==============================================================
debug() {
    process_servers debug_job
}

# Main logic based on mode
case $mode in
  "run")        run ;;
  "script")     script ;;
  "ping")       ping ;;
  "upload")     upload ;;
  "collect")    collect ;;
  "update")     update;;
  "debug")      debug ;;
  *) show_help; exit 1;;
esac
