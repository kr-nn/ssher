#!/usr/bin/env bash
#
# What is this?
# This is a general tool for SSH and auditability. No need to learn complex software like ansible
# This is a simpler quicker to RnD ansible
# This is a simpler tool that uses only 1 dependancy and it's optional: sshpass
# Otherwise all you need is a posix compliant shell and ssh
#
# What is it not?
# This is NOT a state management or configuration management engine.
# This does NOT replace SALT/puppet/Chef
# This will not expand past a few simple but robust capabilities

#_ Initialize variables ==============================================================
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
CLEAR='\033[0m'

mode=0
inventory=0
options=0
username=0
password=0
idfile=0
localfile=0
remotefile=0
cmd=0
jobs=$(nproc)
usetui=0
job_tmpdir=0
current_runner=0

if which sshpass &> /dev/null; then
    sshpass=1
else
    echo -e "${RED}"
    echo "WARNING: sshpass not installed or not in path."
    echo "You will need to install it if you don't want to enter passwords manually"
    echo -ne "${CLEAR}"
    sshpass=0
fi

# shellcheck disable=SC2046
show_help() {
  echo -e "
$(printf '=%.0s' $(seq 1 $(tput cols)))
 ${GREEN}███████╗███████╗██╗  ██╗███████╗██████╗
 ${GREEN}██╔════╝██╔════╝██║  ██║██╔════╝██╔══██╗
 ${GREEN}███████╗███████╗███████║█████╗  ██████╔╝
 ${GREEN}╚════██║╚════██║██╔══██║██╔══╝  ██╔══██╗
 ${GREEN}███████║███████║██║  ██║███████╗██║  ██║
 ${GREEN}╚══════╝╚══════╝╚═╝  ╚═╝╚══════╝╚═╝  ╚═╝${CLEAR}
$(printf '=%.0s' $(seq 1 $(tput cols)))
  Usage:${RED} ssher ${GREEN}-m mode -i inventory_file_path [-u username] [-p] [-s private_key] [-l local_file] [-r remote_file] [-c 'command'] [-J jobs]

  Options:
 ${RED}   -m mode                ${GREEN}Specifies the mode of operation. Options are 'run', 'script', 'ping', 'ins', 'download', 'upload', or 'man'.
 ${RED}                          ${GREEN}use 'debug' to get output of the options per server
 ${RED}                          ${GREEN}This option is required.
 ${RED}
 ${RED}                          ${GREEN}run       =  Run a command on all the servers
 ${RED}                          ${GREEN}script    =  Like run except runs a full script you have locally. If you need to run a script on the server or from a remote location use the run mode.
 ${RED}                          ${GREEN}ping      =  Test SSH access to servers, reports the auth mechanism
 ${RED}                          ${GREEN}ins       =  Add contents of a local file to a target file on the server. Good for pushing public keys with password mode (better than ssh-copy-id)
 ${RED}                          ${GREEN}download  =  Pull contents from remote servers to the local server. Great for auditing/updating configurations.
 ${RED}                          ${GREEN}upload    =  Push contents from local server to the remote servers. Great for uploading configurations.
 ${RED}                          ${GREEN}man       =  Run tasks on the servers manually in sequence. (Good for when you need to authenticate using run) (Good for macros)
 ${RED}                          ${GREEN}debug     =  output what is going to run on each server. Useful when using special variables to change things dynamically
 ${RED}
 ${RED}   -i inventory_file      ${GREEN}Path to the file containing a list of server hostnames or IP addresses.
 ${RED}                          ${GREEN}This option is required.
 ${RED}
 ${RED}   -o options             ${GREEN}define custom ssh options
 ${RED}                          ${GREEN}just like in normal ssh you can pass -o options.
 ${RED}                          ${GREEN}by default stricthostchecking is disabled and connection timeouts are set to 8 seconds
 ${RED}                          ${GREEN}this is not limited to -o you can pass ANY ssh options to this flag
 ${RED}                          ${GREEN}If you use this option stricthostchecking and the connectiontimout options are removed, you will need to add them again
 ${RED}
 ${RED}   -J jobs                ${GREEN}parallel jobs. default is cpu count
 ${RED}
 ${RED}   -p                     ${GREEN}Prompts for a password for password authentication. (THIS REQUIRES SSHPASS)
 ${RED}                          ${GREEN}If not provided, you will have to enter the password for each server that needs it.
 ${RED}                          ${GREEN}Not using this is useful when you have different passwords on different servers
 ${RED}
 ${RED}   -l local_file          ${GREEN}Specifies the file which content to push. Optional.
 ${RED}                          ${GREEN}Default is your public key 'id_rsa.pub'.
 ${RED}                          ${GREEN}Used in script mode to define the script you want to run
 ${RED}
 ${RED}   -r remote_file         ${GREEN}Specifies the file to push local file contents to. Optional.
 ${RED}                          ${GREEN}Default is the remote authorized keys file 'authorized_keys'.
 ${RED}
 ${RED}   -s Private_key         ${GREEN}Specifies the identity key file to use for authentication. Optional.
 ${RED}                          ${GREEN}Default is according to your config file or just 'id_rsa'.
 ${RED}
 ${RED}   -u username            ${GREEN}Specifies the username for the operation. Optional.
 ${RED}                          ${GREEN}Default is the current user's username.
 ${RED}
 ${RED}   -c command             ${GREEN}The command to run when in run mode.
 ${RED}                          ${GREEN}Wrap with \"\" when there's spaces (most of the time)
 ${RED}
  Examples:
   ${RED}ssher ${GREEN}-m run -i oldservers.txt -c 'apt update && apt upgrade -y && apt autoremove -y'                    ${CLEAR}# Update a list of servers
   ${RED}ssher ${GREEN}-m ping -i serversthatshouldbelocked.txt -u root -p | tee sshaudit.txt                             ${CLEAR}# Check what servers are not secured
   ${RED}ssher ${GREEN}-m ins -i newserver.txt -u newkid -l ~/.ssh/newuser.pub                                            ${CLEAR}# Add a new users public key to the server
   ${RED}ssher ${GREEN}-m ping -i servers.txt -u root -o '-J root@jumphost.ip' -u root                                    ${CLEAR}# Add a jumphost for pivoting from
   ${RED}ssher ${GREEN}-m ins -i service.txt -u root -l ./config.txt -d /etc/service/configuration.txt                    ${CLEAR}# set configuration file on server
   ${RED}ssher ${GREEN}-m man -i bootstrapthese.txt -u root -p                                                            ${CLEAR}# Manually perform common tasks back to back
   ${RED}ssher ${GREEN}-m ping -i servers.txt -u user -s ~/.ssh/newkey.id_rsa                                             ${CLEAR}# Check what servers have your new key
   ${RED}ssher ${GREEN}-m script -i servers.txt -u root -l ~/.local/bin/profileconfig.sh                                  ${CLEAR}# configure your shell profile on all servers
   ${RED}ssher ${GREEN}-m download -i servers.txt -u root -l ~/reports/\$date_auth.log -r /var/log/auth.log                ${CLEAR}# pull all the auth logs to investigate today's access
   ${RED}ssher ${GREEN}-m upload -i servers.txt -u root -l ~/.confs/static_ips -r /etc/networking/interfaces              ${CLEAR}# after downloading interfaces files you and update them, then upload them
   ${RED}ssher ${GREEN}-m run -i servers.txt -u root -c 'reboot'                                                          ${CLEAR}# reboot all servers
   ${RED}ssher ${GREEN}-m run -i servers.txt -u root -c 'systemctl --failed'                                              ${CLEAR}# list all failed services in your network

  PROTIPS:
  ${RED}building inventories is easy with nmap:${GREEN} nmap -n -Pn -p 22 192.168.4.0/24 -oG - | grep 'open' | awk '{ print \$2 }'

  ${RED}Create a Report that you can read:${CLEAR}
  ${GREEN}ssher -m ping -i ips.list |tee date.report${CLEAR} # This outputs the color mask for bash, make sure to cat the file to get the color output appropriately
                             ${GREEN}cat date.report${CLEAR} # vim does not render ANSI escape codes without help use cat, more, less as much as you can

$(printf '=%.0s' $(seq 1 $(tput cols)))" | less

}

#_ Parse & setup options ==============================================================
while getopts ":m:i:o:u:s:pl:r:c:J:" opt; do
  case $opt in
    m) mode="$OPTARG";;
    i) inventory="$OPTARG";;
    o) options="$OPTARG";;
    p) password="1";;
    l) localfile="$OPTARG";;
    r) remotefile="$OPTARG";;
    s) idfile="$OPTARG";;
    u) username="$OPTARG";;
    c) cmd="$OPTARG";;
    J) jobs="$OPTARG";;
    *) show_help; exit 1;;
  esac
done

[[ "$mode" == 0 || "$inventory" == 0 ]] && { show_help; exit 1; }
[[ ! -f "$inventory" ]] && { echo "FATAL: Selected inventory file (${inventory}) doesn't seem to exist. Check your pwd."; exit 1; }

[[ "$mode" == "run" ]] && [[ "$cmd" == 0 ]] && { echo "FATAL: Run mode requires -c"; exit 1; }

[[ "$localfile" == 0 ]] && { localfile="$HOME/.ssh/id_ed25519.pub"; }
# shellcheck disable=SC2088
[[ "$remotefile" == 0 ]] && { remotefile='~/.ssh/authorized_keys'; }
[[ "$username" == 0 ]] && { username=$USER; }

# shellcheck disable=SC2015
[[ "$idfile" == 0 ]] && { idfilecmd=""; idfile="$HOME/.ssh/config"; } || { idfilecmd="-i ${idfile} "; }
[[ ! -f ${idfile} ]] && { echo "FATAL: Selected private key or configuration file ${idfile} doesn't seem to exist."; exit 1; }

[[ $sshpass -eq 0 && $password == "1" ]] && { echo "FATAL: Using -p with sshpass not available."; exit 1; }
[[ "$password" == "1" ]] && { read -r -s -p "Input the password: " password; }

[[ $mode == "ins" ]] && { echo ""; read -r -p "Append or overwrite? [a/o] " write; }
# shellcheck disable=SC2015
[[ $write == "o" || $write == "O" ]] && { overwrite=1; } || { overwrite=0; }

# shellcheck disable=SC2015
[[ "$options" == 0 ]] && { optionscmd="-o StrictHostKeyChecking=no -o ConnectTimeout=3 -o BatchMode=yes"; } || { optionscmd="${options}"; }

# shellcheck disable=SC2015
[[ $password == 0 ]] && { passwordcmd=""; } || { passwordcmd="sshpass -p ${password} "; passwordcmdredacted="sshpass -p REDACTED "; }

sshcmdredacted="${passwordcmdredacted}ssh ${idfilecmd} ${optionscmd}"
sshcmd="${passwordcmd}ssh ${idfilecmd} ${optionscmd}"

echo ""
echo -e "Private Key: ${GREEN}$idfile${CLEAR} (change with -s)"
echo -e "local file: ${GREEN}$localfile${CLEAR} (change with -l)"

# shellcheck disable=SC2015
[[ $overwrite == 1 ]] && { echo -e "Write mode: ${RED}Overwrite${CLEAR}"; } || { echo -e "Write mode: ${GREEN}Append${CLEAR}"; }
[[ $remotefile != 0 ]] && { echo -e "remote file: ${GREEN}$remotefile${CLEAR}"; }

echo -e "Username: ${GREEN}$username${CLEAR} (change with -u)"
echo -e "Servers to attempt (cat the file if you're unsure): ${GREEN}$inventory${CLEAR}"

[[ "$cmd" != 0 ]] && { echo -e "Command: ${GREEN}$cmd${CLEAR}"; }

echo -e "SSH: ${GREEN}${sshcmdredacted}${CLEAR}"

countdowntime=3
while [ $countdowntime -gt 0 ]; do
    echo -ne "${RED}Make sure to read this! $countdowntime\033[0K\r${CLEAR}"
    sleep 1
    countdowntime=$((countdowntime-1))
done

read -r -p "Are you sure you want to run this? [y/n] " confirm
case "$confirm" in
    [yY][eE][sS]|[yY])
        ;;
    *)
        exit 1
        ;;
esac
echo ""
echo "=============================================================="

draw_tui() {
    queued=$((total_hosts - success_hosts - failed_hosts))
    printf '\rQueued: %d / Success: %d / Failed: %d    ' "$queued" "$success_hosts" "$failed_hosts"
}

cleanup_jobs() {
    [[ $usetui -eq 1 ]] && { tput cnorm; usetui=0; }
    [[ "$job_tmpdir" != 0 && -d "$job_tmpdir" ]] && rm -rf "$job_tmpdir"
    job_tmpdir=0
}

launch_job() {
    idx="$1"
    server="${servers[$idx]}"
    outfile="$job_tmpdir/$idx"
    (
        "${current_runner}" "$server" "$outfile"
    ) &
    pids[$idx]=$!
}

process_servers() {
    current_runner="$1"
    mapfile -t servers < "$inventory"
    total_hosts=${#servers[@]}
    [[ $total_hosts -eq 0 ]] && { cleanup_jobs; trap - EXIT; return; }
    success_hosts=0
    failed_hosts=0
    pids=()
    job_tmpdir=$(mktemp -d)
    trap cleanup_jobs EXIT
    if [ -t 1 ] && [ "$jobs" -gt 1 ]; then
        usetui=1
        tput civis
        draw_tui
    fi
    launch_idx=0
    active=0
    declare -A pid_index=()
    while [ $launch_idx -lt $total_hosts ] || [ $active -gt 0 ]; do
        while [ $launch_idx -lt $total_hosts ] && [ $active -lt "$jobs" ]; do
            launch_job "$launch_idx"
            pid=${pids[$launch_idx]}
            pid_index[$pid]=$launch_idx
            launch_idx=$((launch_idx+1))
            active=$((active+1))
        done
        for pid in "${!pid_index[@]}"; do
            wait "$pid"
            status=$?
            idx=${pid_index[$pid]}
            unset pid_index["$pid"]
            active=$((active-1))
            if [ $status -eq 0 ]; then
                success_hosts=$((success_hosts+1))
            else
                failed_hosts=$((failed_hosts+1))
            fi
            if [ $usetui -eq 1 ]; then
                draw_tui
            fi
            break
        done
    done
    if [ $usetui -eq 1 ]; then
        printf '\rQueued: 0 / Success: %d / Failed: %d    \n' "$success_hosts" "$failed_hosts"
        tput cnorm
        usetui=0
    fi
    if [ "$mode" == "download" ]; then
        for ((idx=0; idx<total_hosts; idx++)); do
            server="${servers[$idx]}"
            echo "" >> "$localfile"
            echo "##\$\$##| ${server} |##\$\$##" >> "$localfile"
            data_file="$job_tmpdir/${idx}.data"
            [ -f "$data_file" ] && cat "$data_file" >> "$localfile"
        done
    fi
    for ((idx=0; idx<total_hosts; idx++)); do
        cat "$job_tmpdir/$idx"
    done
    cleanup_jobs
    trap - EXIT
}

#_ Jobs ==============================================================
run_job() {
    server="$1"
    outfile="$2"
    ssh_output=$($sshcmd "$username@${server}" "${cmd}" 2>&1 < /dev/null)
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

script_job() {
    server="$1"
    outfile="$2"
    ssh_output=$($sshcmd "$username@${server}" 'bash -s' < "${localfile}" 2>&1 < /dev/null)
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

ping_job() {
    server="$1"
    outfile="$2"
    ssh_output=$($sshcmd "$username@${server}" -v exit 0 2>&1 < /dev/null)
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            if echo "$ssh_output" | grep -q "Server accepts key:"; then
                echo -e "${GREEN}Public key authentication${CLEAR}"
            else
                echo -e "${YELLOW}Password Authentication${CLEAR}"
            fi
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

ins_job() {
    server="$1"
    outfile="$2"
    ssh_output=$($sshcmd "$username@${server}" "cat >> ${remotefile}" < "$localfile" 2>&1 < /dev/null)
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $localfile"
            echo "To: $remotefile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

download_job() {
    server="$1"
    outfile="$2"
    data_file="${outfile}.data"
    ssh_output=$($sshcmd "$username@${server}" "cat ${remotefile}" > "$data_file" 2>&1 < /dev/null)
    status=$?
    {
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $remotefile"
            echo "To: $localfile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

upload_job() {
    server="$1"
    outfile="$2"
    content=$(sed -n "/^##\$\$##| ${server} |##\$\$##$/,/^##\$\$##| /{ /^##\$\$##| ${server} |##\$\$##$/d; /^##\$\$##| /d; p; }" "$localfile" | sed '/^$/d')
    ssh_output=$($sshcmd "$username@${server}" "echo $content > ${remotefile}" 2>&1 < /dev/null)
    status=$?
    {
        echo "# ============================ ${server} ==================================="
        if [ $status -eq 0 ]; then
            echo -e "${GREEN}SUCCESS ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "Wrote: $localfile"
            echo "To: $remotefile"
            echo "=============================================================="
        else
            echo -e "${RED}FAILED ${server}${CLEAR}"
            echo "--------------------------------------------------------------"
            echo "$ssh_output"
            echo "=============================================================="
        fi
    } > "$outfile"
    return $status
}

debug_job() {
    server="$1"
    outfile="$2"
    {
        echo "=============================================================="
        echo -e "${GREEN}debug mode - ${server}${CLEAR}"
        echo "--------------------------------------------------------------"
        echo -e "Inventory:   ${GREEN}  $inventory  ${CLEAR}"
        echo -e "Username:    ${GREEN}  $username  ${CLEAR}"
        echo -e "Idfile:      ${GREEN}  $idfile  ${CLEAR}"
        echo -e "Password:    ${GREEN}  $password  ${CLEAR}"
        echo -e "local file:  ${GREEN}  $localfile  ${CLEAR}"
        echo -e "remote file: ${GREEN}  $remotefile  ${CLEAR}"
        echo -e "Command:     ${GREEN}  $cmd  ${CLEAR}"
    } > "$outfile"
}

#_ Run ==============================================================
run() {
    [[ "$cmd" == 0 ]] && { echo "FATAL: you need -c to run a command on the servers"; exit 0; }
    [[ "$cmd" == '' ]] && { echo "FATAL: empty commands make your shell broken"; exit 1; }
    process_servers run_job
}

#_ Script ==============================================================
script() {
    # fail if option is missing
    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to choose a script file locally"
        exit 0
    fi

    # Fail if local file is not found
    if [ ! -f "$localfile" ]; then
        echo "FATAL: Selected local file (${localfile}) doesn't seem to exist. Check your pwd."
        exit 1
    fi

    process_servers script_job
}

#_ ping ==============================================================
ping() {
    process_servers ping_job
}

#_ insert ==============================================================
ins() {
    # Fail if requirements are missing
    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to have content to push"
        exit 0
    fi

    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to push the content to"
        exit 0
    fi

    # Fail if local file is not found
    if [ ! -f "$localfile" ]; then
        echo "FATAL: Selected local file (${localfile}) doesn't seem to exist. Check your pwd."
        exit 1
    fi

    process_servers ins_job
}

#_ Download ==============================================================
download() {

    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to put the content somewhere"
        exit 0
    fi

    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to pull the content"
        exit 0
    fi

    process_servers download_job
}

#_ upload ==============================================================
upload() {

    if [ "$localfile" == 0 ]; then
        echo "FATAL: you need -l to push the content somewhere"
        exit 0
    fi
    if [ "$remotefile" == 0 ]; then
        echo "FATAL: you need -r to put the content somewhere"
        exit 0
    fi

    process_servers upload_job
}

#_ manual ==============================================================
man() {
    while IFS= read -r server; do
        $sshcmd "$username@${server}"
    done < "$inventory"
}

#_ debug ==============================================================
debug() {
    process_servers debug_job
}

# Main logic based on mode
case $mode in
  "run")        run ;;
  "script")     script ;;
  "ping")       ping ;;
  "ins")        ins ;;
  "download")   download ;;
  "upload")     upload ;;
  "man")        man ;;
  "debug")      debug ;;
  *) show_help; exit 1;;
esac
